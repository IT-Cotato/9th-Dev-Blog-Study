### 서론
취업준비를 하며 웹개발자 직군에 많이 지원했는데, 막연하게 '난 백엔드니까 API 잘 쏴주고, DB 잘 관리하면 되겠지!'라는 생각에 프론트엔드 쪽은 거의 손을 놓고 있었다. 그래도 '웹'개발자인데 전문가까지는 아니더라도 '웹'에 대해서는 알아야 자격이 있지 않을까...늦은 감이 있긴 한데 차근차근 알아가보자.

### Web Application Architecture
![alt text](image1.png)
> * Client: 사용자가 서버에 요청을 보낼 수 있게 해주는 컴퓨터나 장치, 프로그램을 의미한다. Chrome과 같은 Browser 또한 여기에 속한다.
* Server: client로 부터의 요청을 처리한 후 이에 맞는 응답을 보내주는 프로그램이나 장치를 의미한다.
* Database: Server의 응답에 필요한 자원들의 저장소이다.

Web Application Architecture은 흔히 우리가 사용하는 웹 애플리케이션에서 client와 server의 연결 및 통신이 진행되는 구조를 의미한다. 사용자는 Client를 통해 특정 작업을 수행하며 이를 통해 Client는 Server로 요청을 보낸다. 요청을 받은 Server는 Database에서 필요한 resource(자원)을 꺼내오며 이를 다시 client에게 응답으로 보내주며 사용자는 웹 애플리케이션의 원하는 기능을 사용한다.

이에 따라 웹 애플리케이션은 클라이언트의 요청을 수신하며 서버로부터 받은 응답을 사용자에게 표시해주는 client side와 비즈니스 로직, DB와의 통신을 통해 클라이언트로 보낼 응답을 관리하는 server side로 나뉘며, 보통 Client Side를 Front-end, Server Side를 Back-end라 표현한다. 



### Web Server vs Application Server
> 근데 client는 1갠데 왜 server는 2개가 있지?

이는 Server가 처리하고 보내줘야할 응답이 2가지이기 때문이다.

#### A. 정적 데이터(or 리소스)
![alt text](image2.png)

클라이언트에서 요청 시 서버에서 데이터를 가공하지 않은 상태로 바로 응답으로 전송할 수 있는 데이터를 의미한다. 대표적인 예로 HTML, CSS, Javascript로 이루어진 html 파일이나 배너의 광고 이미지 등 따로 비즈니스 로직 없이 초기의 상태 그대로인 데이터들을 의미한다.

#### B. 동적 데이터
![alt text](image3.png)

정적 데이터와 반대로 클라이언트의 요청 처리에서 비즈니스 로직이 개입되거나 DB의 리소스를 가져와야하는 등, 보낼 응답의 형태가 고정되지 않은 데이터를 의미한다. 사용자의 글 작성으로 변하는 게시판이나, 점수 등이 여기에 속한다.


#### C. 요청의 흐름
![alt text](image4.png)출처:pxd xe group

> * Web Server는 정적 리소스를 Client로 보내주며, Client에서 보낸 정적 리소스 및 요청들을 저장하거나 처리한다. ex) NGINX, Apache HTTP Server, Tomcat
* Application Server(웹에서는 Web Application Server, 줄여서 WAS)는 Web Server가 처리하지 못하는 동적 리소스나 요청을 받아, 비즈니스 로직이나 DB를 이용해 요청을 처리한 후 이를 Client로 보내준다. ex) Oracle WebLogic, TmaxSoft JEUS


> _웹 애플리케이션을 음식점으로 비유해보자. 여기서 Client 혹은 브라우저는 '손님', 웹서버는 '웨이터', 애플리케이션 서버는 '셰프'에 비유할 수 있다. '손님'이 주문(요청)을 하는 경우, '웨이터'는 식전빵, 포크, 나이프 등 바로 준비 가능한 것(정적 데이터)은 바로 손님에게 가져다주고, 요리(동적 데이터)는 '쉐프'에게 가져다주며, 요리가 끝나면 이를 웨이터는 손님에게 가져다준다._

Client를 통해 들어온 요청은 우선 Web Server에 도달한다. Web Server는 이를 판단 후 자신이 처리할 수 있는 요청은 처리하되, 나머지 요청은 Application Server로 보낸다. Application Server는 이를 받아 처리 후 완료된 응답을 Web Server를 통해 다시 Client로 전달한다. 2개의 서버 모두 통신은 HTTP 프로토콜을 따른다.

HTML 파일은 정적인 파일이므로 여기서 브라우저 렌더링 과정은 Web Server와 Client 사이에서 이루어진다.

> *** 잠깐! 그럼 WAS 하나만 있어도 정적, 동적인 처리 모두 가능하지 않을까? 웹 서버는 왜 굳이 있어야하지?**
--> 컴퓨터공학에 있어 중요한 것은 효율성이다. WAS 하나만으로도 이론적으로는 웹 서버의 작업까지 처리가 가능하지만 이는 서비스의 주요 로직들을 처리해야하는 WAS에 부하를 줄 수 있기에, 정적인 작업들을 웹 서버가 처리해주는 것이 더 안전하고 정확하며, 빠른 서비스 제공에 유리하기 때문에, 2개의 서버를 모두 채용하는 것을 지향한다.
(셰프가 서빙까지 다하면 너무 힘들잖아)

### 브라우저의 구조 및 렌더링 과정

![alt text](image5.png)

브라우저란 서버로부터 전달받은 HTML이나 PDF 파일 등을 통해 인터넷 웹 페이지를 사용자에게 보여주는 프로그램 혹은 소프트웨어이다. 흔히 사용하는 크롬, 엣지, 인터넷 익스플로러 등이 모두 브라우저이다. 브라우저의 구조는 다음과 같다.

> 1. 사용자 인터페이스(UI): 사용자와 상호작용할 수 있는 화면 내 모든 것을 의미한다. 웹 페이지를 표시하는 데 사용되는 주소 표시줄, 이전/다음 페이지로 이동하는 버튼, 북마크 등과 같은 도구 모음, 탭을 통해 여러 웹 페이지를 동시에 열 수 있는 탭 관리기 등을 포함한다.
2. 브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어해주는 엔진이다. 서버로부터 받은 HTML 및 CSS 파일을 파싱(해석)하고 이를 DOM 형태로 변환한다.
3. 렌더링 엔진: 서버로부터 받은 HTML 및 CSS 파일을 파싱(해석)하며 이를 화면에 띄워주는 엔진이다. 종종 브라우저 엔진과 의미가 혼용돼서 사용된다.
4. 통신: HTTP 요청과 같은 네트워크 호출에 사용된다. 사용자 인터페이스로부터 요청이 들어와 DNS를 통해 IP 주소를 찾는 작업 등에 기여한다.
5. 자바스크립트 해석기: JavaScript 코드를 해석한다.
6. UI 백엔드: 렌더링 엔진이 생성한 Render Tree를 브라우저에 그린다.
7. 자료 저장소(웹 스토리지): 서버로 보내지지 않으며 클라이언트가 가지는 저장소이다. 로컬 스토리지와 세션 스토리지가 존재한다.

본 글에서 파헤쳐 볼 부분은 브라우저의 화면 렌더링 과정이므로 애플리케이션 서버까지의 과정이 아닌 웹 서버(HTTP 서버)와 클라이언트 사이에서의 흐름에 집중해보자.
![alt text](image6.png)

### Step1. 사용자 요청
사용자는 접속하고 싶은 웹의 주소를 Chrome 브라우저에 주소창에 친다. 이 도메인에 맞는 IP 주소를 찾기 위해 브라우저의 통신을 거쳐 DNS에 해당 도메인과 맞는 IP 주소를 찾아온다.

### Step2. Render Tree 생성
![alt text](image7.png)
IP 주소를 찾은 후에 해당 웹 서버에서 주소에 맞는 HTML 파일을 보내준다. 이후 렌더링 엔진은 HTML 파일 내의 HTML과 CSS를 파싱(해석)한다. 이때 렌더링 엔진은 HTML과 CSS를 따로 해석하는데 이는 각각 DOM(Document Object Model)과 CSSOM(CSS Object Model) 형태로 변환된다. 여기서 script 태그의 javascript는 렌더링 엔진이 아닌 javascript 해석기가 담당한다.

- _브라우저 엔진 / 렌더링 엔진이 예전에는 브라우저마다 상이했기 때문에 같은 html 파일이여도 다른 화면이 출력되는 상황이 빈번했으나 html5 이후 브라우저 엔진이 거의 통합되어 현재는 이러한 문제의 발생이 적다._

DOM,CSSOM 그리고 javascript의 해석이 완료된 후 이 셋을 모두 합쳐 Render Tree를 생성한다. 이는 모든 요소의 적용 이후 그려질 결과 화면만을 그리기 위해서이다.

예시로 다음과 같은 html 파일의 일부가 있다고 생각해보자

```
<style>
  div{
  	display: none;
  }
  </style>
  
  <div>안녕!</div>
```
div 태그는 css style에 의해 화면에는 그려지지 않는다. 따라서 DOM에는 div가 있지만 결과적으로 Render Tree에는 div가 존재하지 않게 된다. 

### Step3. Layout & Paint

Render Tree만을 가지고는 화면에 표시될 요소들의 정확한 위치가 불분명하기 때문에, 렌더링 엔진은 루트 노드 부터 순회하며 각 요소의 화면 내 위치를 정하는데 이를 **_Layout 과정_** 이라고 한다. Layout 과정이 끝난 이후 UI 백엔드는 이를 토대로 화면을 그리는데 이를 **_Paint_** 라 표현한다.

Javascript에 의해 화면이 동적으로 바뀌는 경우에는 다시 Layout, Paint 과정을 거치는데 이를 리플로우(레이아웃 계산을 다시 하는 것), 리페인트(재결합된 렌더링 트리를 기반으로 다시 페인트를 하는 것) 한다고 표현한다.

### +alpha
> Javascript는 태그에 직접 손대는 게 아니다. 객체(DOM, CSSOM)에 손을 대는 것! 코드 상으로는 html 파일 내부에서 script를 통해 html 태그들이 조작 되는 것처럼 보이지만 실제로는 이 태그는 가만히 있고, 태그들을 통해 생성된 DOM, CSSOM를 건드려 화면의 동적 변화를 일으키는 것!




조금 중구난방, 렌더링 과정만 설명하려다 살이 덕지덕지 붙어 조금 긴 글이 된것같은... 다음에는 서버 사이드, 애플리케이션 과정에 대해서도 정리해봐야겠다.

